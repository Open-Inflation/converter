# converter

Конвертер работает уже с спарсенными данными и преобразовывает их для постоянного хранения (в отдельную БД). Конвертер делегирует работу с данными модулям в зависимости от парсера в ране. Так например:

1. fixprice:
Имеет общий паттерн вида:
`Название, Бренд(опционально), floatXfloat ИЛИ floatXfloatXfloat ИЛИ float (см/мл/л), int(сколько штук (сопряженное слово может быть любым), опционально), в ассортименте`
Пример:
`Ручка гелевая "Помада", With Love, 10х1,5 см, в ассортименте`
Нужно:
1. Сосчитать unit, нормализировать название, так же предоставить оригинальное название без стоп-слов и нормализированное название без стоп слов
Юнит:
    # Unit guide:
    # Chocolate 200 g:
    #   unit="PCE", available_count=15, package_quantity=0.2, package_unit="KGM"
    # Milk 1 L:
    #   unit="PCE", available_count=10, package_quantity=1, package_unit="LTR"
    # Potatoes by weight:
    #   unit="KGM", available_count=12.7, package_quantity=None, package_unit=None
    # Water vending:
    #   unit="LTR", available_count=29.2, package_quantity=0.5, package_unit="LTR"
    unit: Literal["PCE", "KGM", "LTR"]
    available_count: int | float | None
    package_quantity: float | None
    package_unit: Literal["KGM", "LTR"] | None

Каждый модуль парсера должен делится на суб модули и жить в отдельных папках

Состав продукта, если имеется, так же нужно нормализировать в отдельным полем. ВАЖНО: данные не теряем, мы их только дополняем.

Так же нормализируем и другое: категории, гео и тп (все в отдельные столбцы).

Общую логику для всех парсеров выводим в мастер класс.

Изображения обрабатываем через персистентный анализ, если они одинаковые, шлем на storage запросы на удаление дубликатов, если разные, сохраняем ссылки на них.

У каждого товара должен быть уникальный ID в базе (не уникальный ключ всмысле СУБД). Когда парсер находит plu/sku+parser_name он автоматически считает что это один товар и присваивает им тот же ID что у оригинала, те NULL значения что у него, автоматически должны подставлятся на не нулл значения у ближайшего по времени не NULL варианта. Та же логика с категориями.

База receiver и база catalog это разные базы данных и данные гоняются из одной в другую.

Смежные проекты:
../dataclass
../storage
../receiver
